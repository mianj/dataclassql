{{ model.include_alias }} = {{ model.include_literal_expr }}
{{ model.sortable_alias }} = {{ model.sortable_literal_expr }}

@dataclass(slots=True, kw_only=True)
class {{ model.insert_class }}:
{{ macros.dataclass_fields(model.insert_fields)|indent(4, True) }}

class {{ model.insert_dict_class }}(TypedDict):
{{ macros.typed_dict_fields(model.typed_dict_fields)|indent(4, True) }}

class {{ model.where_dict_class }}(TypedDict, total=False):
{{ macros.where_fields(model.where_fields)|indent(4, True) }}

class {{ model.table_class }}:
    model = {{ model.name }}
    insert_model = {{ model.insert_class }}
    datasource = {{ model.datasource_expr }}
{{ macros.column_specs(model.column_specs)|indent(4, True) }}
    column_specs_by_name: Mapping[str, ColumnSpec] = MappingProxyType({spec.name: spec for spec in column_specs})
    primary_key: tuple[str, ...] = {{ model.primary_key_literal }}
    indexes: tuple[tuple[str, ...], ...] = {{ model.indexes_literal }}
    unique_indexes: tuple[tuple[str, ...], ...] = {{ model.unique_indexes_literal }}
{{ macros.foreign_keys(model.foreign_keys)|indent(4, True) }}
{{ macros.relations(model.relation_entries)|indent(4, True) }}

    def __init__(self, backend: {{ model.backend_protocol_annotation }}) -> None:
        self._backend: {{ model.backend_protocol_annotation }} = backend

    def insert(self, data: {{ model.insert_union_annotation }}) -> {{ model.name }}:
        return self._backend.insert(self, data)

    def insert_many(self, data: {{ model.insert_many_sequence_annotation }}, *, batch_size: int | None = None) -> {{ model.insert_many_return_annotation }}:
        return self._backend.insert_many(self, data, batch_size=batch_size)

    def find_many(self, *, where: {{ model.where_dict_class }} | None = None, include: {{ model.include_annotation }} = None, order_by: {{ model.order_by_annotation }} = None, take: int | None = None, skip: int | None = None) -> {{ model.insert_many_return_annotation }}:
        return self._backend.find_many(self, where=where, include=cast(Mapping[str, bool] | None, include), order_by=order_by, take=take, skip=skip)

    def find_first(self, *, where: {{ model.where_dict_class }} | None = None, include: {{ model.include_annotation }} = None, order_by: {{ model.order_by_annotation }} = None, skip: int | None = None) -> {{ model.find_first_return_annotation }}:
        return self._backend.find_first(self, where=where, include=cast(Mapping[str, bool] | None, include), order_by=order_by, skip=skip)

